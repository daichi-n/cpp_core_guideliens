I.7: State postconditions
(事後条件を明示する)

関数の処理の期待値を明確にする。リソース開放などに関しては可能な限り実装上で表現する。

I.8: Prefer Ensures() for expressing postconditions
(事後条件を明示するのにEnsures()を使う)

関数の処理の期待値をEnsures()で明示する。ただし、本案件ではほぼ使用ししていない。リソース開放などに関しては可能な限り実装上で表現する。

I.9: If an interface is a template, document its parameters using concepts
(インターフェースがテンプレートの場合、引数にコンセプトで注釈をつける)

C++20から導入される「コンセプト (concepts)」で、テンプレートパラメータを制約する。

I.10: Use exceptions to signal a failure to perform a required task
(必要な措置を講じるために失敗の通知には例外を使う)

エラーとは関数が呼びもとに期待された動作を実現できなかったこと。エラーを起こした場合は例外を投げるべき。例外を使えない場合は値,エラーコードの戻り値を検討する。

I.11: Never transfer ownership by a raw pointer (T*) or reference (T&)
(決して生ポインタで所有権を渡さない)

生ポインタはリソースリークや使用前のリリースを招き、バグにつながる。

I.12: Declare a pointer that must not be null as not_null
(nullになってはいけないポインターは、(GSLの)not_nullとして宣言する)

not_nullが定義されていないポインタを使用する際は常にnullの可能性を考慮する。not_nullはおそらく使用しない。

I.13: Do not pass an array as a single pointer
(配列をポインター1つだけで渡さない)

引数がポインタ+サイズの場合、その関数の中で配列の領域外アクセスをする可能性を防げない。引数をspanやvectorに変えることを検討する。

I.22: Avoid complex initialization of global objects
(グローバルオブジェクトの複雑な初期化は避ける)

翻訳単位が異なるグローバルオブジェクトの呼び出し順序は不定のため、グローバルオブジェクト同士が相互に参照して初期化すると一方は不定の値で初期化することになる。

I.23: Keep the number of function arguments low
(できるだけ引数の数は少なくする)

引数が多い関数は抽象化が足りていない。関数の処理パターンがコントロールできなくなりエラーにつながる。また、単一機能単一責任になっておらず、複数の役割を担おうとしており、リファクタの対象と判断できる。パラメータはなるべく4つまでとする。

I.24: Avoid adjacent unrelated parameters of the same type
(同じ型の無関係な引数が隣接しないようにする)

引数の順序が意味をなす場合に、同じ型がならぶとどちらが入力でどちらが出力なのかを読み手に混乱させる。配列のコピー元、コピー先など。
パラメータを構造体にして各引数の役割を変数名で明確にする。


I.25: Prefer abstract classes as interfaces to class hierarchies
(クラス階層よりもインターフェースとしての抽象クラスを使う)

データを持たないインタフェースクラスを継承したほうが、各継承クラスの実装がシンプルになる。

I.26: If you want a cross-compiler ABI, use a C-style subset
(コンパイラを跨ぐABIが必要なら、C言語の機能に絞ったサブセットを使う)

コンパイラによって、クラス、例外処理、関数名など、実装の詳細が異なるバイナリレイアウトを実装しているため。

I.27: For stable library ABI, consider the Pimpl idiom
(安定したライブラリのABIのためにPimplパターンの使用を検討する)

軽微な修正による再コンパイルを避けるためにPimplパターンの使用を検討する。

I.30: Encapsulate rule violations
(ルール違反をカプセル化する)

設計上どうしても必要なイレギュラーな実装は別のユーザーから参照できない内部の実装にとどめる。インタフェースとして見える箇所には漏れないようにする。

F.1: "Package" meaningful operations as carefully named functions
(意味のある一連の処理を関数に注意深く命名して、「まとめる」)

コードの可読性と再利用性を高めるために、アクションが一連の流れとして規定されているものは正しい名前をつけてまとめること。

F.2: A function should perform a single logical operation
(関数は論理的に1つの処理のみをするべきである)

シンプルな関数は読み手が理解しやすく、テスト、再利用もしやすい。

F.3: Keep functions short and simple
(関数は短くシンプルに保つ)

長い関数は制御も複雑になり、エラーを隠す可能性が高くなる。画面におさまらない関数は、意味のある単位で小さな関数に分割する。

F.4: If a function may have to be evaluated at compile time, declare it constexpr
(関数がコンパイル時に評価されうるなら、constexprで宣言する)

コンパイル時点でエラーチェックができROM化することができる。

F.5: If a function is very small and time-critical, declare it inline
(関数が非常に小さく時間的制約が強ければ、inlineで宣言する)


インライン関数はABIの一部のため、安定したインターフェイスであることを意図しているものには、今後の変更されないことが確実でない限り、インライン関数を置かない。
関数テンプレートは通常ヘッダ定義のためインラインになる。
constexprはinlineを意味する。
クラス内で定義されたメンバ関数は、デフォルトでインライン化されます。
★要確認

F.6: If your function may not throw, declare it noexcept
(関数が例外を投げないなら、noexceptで宣言する)

noexcept関数を宣言すると、代替実行経路の数を減らすことができ、最適化の助けになります。また、失敗後の終了を早めることができます。
C言語や例外のない他の言語で完全に書かれたすべての関数にnoexceptを付けるべき。
noexceptは、頻繁に使用される低レベルの関数に最も有効。

F.7: For general use, take T* or T& arguments rather than smart pointers
(一般的な用途の引数にはスマートポインタより普通のポインタまたは参照を使う)

スマートポインタ（std::shared_ptrなど）を渡すと、ランタイムコストが発生する。
★要検討

F.8: Prefer pure functions
(関数はできるだけ純粋関数(副作用のない関数)にする)

純粋関数はシンプルで最適化しやすくROM化もできるため。

F.9: Unused parameters should be unnamed
(使用しない仮引数に名前を付けてはいけない)

読みやすさの向上と未使用パラメータに対する警告を避けるため。
パラメータが条件付きで未使用になる場合は、[[maybe_unused]]属性で宣言する。

F.10: If an operation can be reused, give it a name
(再利用できる操作であれば、名前をつけておく。)

無名ラムダの役割が増えすぎた場合などに、その役割を明確にし、読みやすくする。

F.11: Use an unnamed lambda if you need a simple function object in one place only
₍シンプルな関数オブジェクトが一か所だけ必要な場合は、無名ラムダを使用します。₎

コードが簡潔になり、代替案よりも優れた局所性を得ることができます。名前付けはたとえ一度しか使用されない場合でも、わかりやすくするために有効です。

F.15: Prefer simple and conventional ways of passing information
(情報を渡す方法はシンプルかつ一般的なものにする)

一般的なテクニックを超えた最適化が本当に必要だと感じたら、それが本当に改善であることを確認するために測定し、改善が移植できないかもしれないので文書化/コメントする。

F.16: For "in" parameters, pass cheaply-copied types by value and others by reference to const
(入力用引数は、安価にコピーできる型は値で渡し、それ以外はconst参照で渡す)

高速かつ単純になり、安全性も確保できる。rvalueによる初期化を可能にする。
？？

F.17: For "in-out" parameters, pass by reference to non-const
(入出力用引数は非const参照で渡す)

非const参照の場合は更新されることが前提であると理解する。ただし、それ自体がバグを引き起こしかねない実装である。span<T>やイテレータはそれ自体が入出力引数になる。

F.18: For “will-move-from” parameters, pass by X&& and std::move the parameter
₍will-move-from」パラメータは、X&&とstd::moveでパラメータを渡します。₎
効率的で、呼び出し先でのバグをなくすことができる。
？？

F.19: For "forward" parameters, pass by T&& and only std::forward the parameter
(転送する引数はT&&にして、引数をstd::forwardする)
オブジェクトが他のコードに渡され、この関数で直接使用されない場合、この関数は引数のconst-nessとrvalue-nessに不可知論的であるようにしたいです。
？？

F.20: For "out" output values, prefer return values to output parameters
(値を返すには、出力用引数よりも戻り値を使う)

戻り値は役割が自明だが、&はin-outかout-onlyの2つの意味があり、誤用される可能性がある。ただし、charを複数持つ構造体などmoveの負荷が高いケースは戻り値だと最適化されない。

F.21: To return multiple "out" values, prefer returning a tuple or struct
(複数の値を返すには、タプルか構造体を使う)

戻り値は役割が自明であるため。戻り値に意味がある場合は構造体、それ以外はタプルを使用する。

F.60: Prefer T* over T& when "no argument" is a valid option
(「値なし」がありえるなら参照ではなくポインターを使う)

参照は関数内でのnullチェックの手間を省くことが一般的であるから。
？？.

C: Classes and class hierarchies / クラスとクラス階層
C.1: Organize related data into structures (structs or classes)
(関連するデータをクラスまたは構造体で組織化する)

可読性の向上のために、データの関連をコード上で表現すること。
仮想関数のない単純なクラスは、スペースや時間のオーバーヘッドがないため、classで表現することにデメリットは少ない。
class(private)とstruct(public)の違いは、メンバーのデフォルトの可視性だけ。

C.2: Use class if the class has an invariant; use struct if the data members can vary independently
(クラスが不変条件を持つならclassを、メンバーが独立に変更できるならstructを使う)

クラスを使用すると、不変条件の必要性がプログラマーに警告されます。？？
不変条件とは、公開関数によってしか変更できない、コンストラクションで初期化されるprivate変数のこと。
不変条件があるならクラスを使用する、ないなら構造体で実装する。

C.3: Represent the distinction between an interface and an implementation using a class
(クラスを使ってインターフェースと実装の区別を表現する)

可読性が向上し、メンテナンスが簡単になる。？？

C.4: Make a function a member only if it needs direct access to the representation of a class
(クラスの内部表現(※privateメンバー)に直接アクセスする必要がある場合に限り、関数をメンバーにする)

クラスのメンバ変数を使用して処理をする必要がない場合はヘルパー関数をクラス外に実装する。

C.5: Place helper functions in the same namespace as the class they support
(ヘルパー関数は対象とするクラスと同じ名前空間に置く)

ヘルパー関数はクラスのメンバ変数などに直接アクセスする必要はないが、クラスの有用なインターフェースの一部とみなされる関数です。クラスと同じ名前空間に置くことで、クラスとの関係が明らかになり、引数に依存した検索が可能になります。

C.7: Don’t define a class or enum and declare a variable of its type in the same statement
(クラスなどの定義とその型の変数の宣言を1文で書かない)

混乱を招くので、型の定義と変数の宣言は同じ行で行わない。

C.8: Use class rather than struct if any member is non-public
(publicではないメンバーがあるなら構造体ではなくクラスを使う)

外部に対して何かを隠したいという意思表示のためにクラスを使用する。
デフォルトがpribateのため、publicにするものを限定しているイメージ。

C.9: Minimize exposure of members
(メンバーの露出を最小限にする)

カプセル化することで、意図しないアクセスを最小化する。これにより、メンテナンスが簡素化される。
メンバ変数に対しての処理を追いやすくする。

C.concrete: Concrete types / 具象型
C.10: Prefer concrete types over class hierarchies
(クラス階層よりも具象クラスを使う)

具体的な型はスタックアロケートされ、他のクラスのメンバとなることができる。
クラス階層だとポインタや参照を通じてそのオブジェクトを操作する必要があり、メモリ・オーバーヘッドなどランタイム・オーバーヘッドになる。

C.11: Make concrete types regular
(具象型の振る舞いを一般的なものにする)

代入や等式など一般的なインターフェースを使用可能なクラス設計にする。理解しやすくなるため。
等価比較演算子も実装して置くのが望ましい。

C.12: Don’t make data members const or references
(データメンバーをconstまたは参照にしない)

コピーできないメンバ変数を持つことは方を使いづらくする。₍参照も部分敵にコピー付加となる。₎

Enum: Enumerations / 列挙
Enum.1: Prefer enumerations over macros
(マクロより列挙型を使う)

マクロはスコープや型の規則がない。同名を複数個所で定義できるため、意図しないマクロが使用されてしまう可能性がある。
また、マクロは前処理中に削除されるため、デバッガーなどのツールでは表示されない。デバッグしづらい。

Enum.2: Use enumerations to represent sets of related named constants
(名前の付いた定数のセットを表すのに列挙型を使う)

関連する定数のセットを、名前付きの型にすることができます。
列挙型にすることで大文字と小文字の違いなど異常なパターンに対してコンパイラがチェックできる。
switch構文で抜け漏れを防ぐこともできる。

Enum.3: Prefer enum classes over "plain" enums
(素のenumよりenum classを使う)

意図しない挙動を最小限にする。従来のenumはintに型変換されて、ほかのラベルを期待する場合でもそれなりにふるまってしまう。
enum classを使えば期待するenumのみを使用しているのかをコンパイラがチェックできる。

Enum.4: Define operations on enumerations for safe and simple use
(列挙型に演算子を定義して安全かつシンプルに使えるようにする)

使いやすさとエラーの回避。面倒な処理のカプセル化と個別の実装でミスをすることによるエラーを回避する。

Enum.5: Don’t use ALL_CAPS for enumerators
(列挙型の名前を全て大文字の名前にしない)

マクロとの衝突を避けるため。

Enum.6: Avoid unnamed enumerations
(無名の列挙型を避ける)

列挙型に名前を付けることができない場合、それは値の設計ができていないことをさす。
関連がないのなら個別にconstexpr で宣言すること。

Enum.7: Specify the underlying type of an enumeration only when necessary
(列挙型の基本型は必要な場合のみ与える)

フォルトは、読み書きが最も簡単です。 デフォルトはintで、C 列挙型と互換性があります。
またメモリの節約にもなる。

Enum.8: Specify enumerator values only when necessary
(列挙子の値は必要な場合のみ与える)

列挙値の重複や抜けを回避し、switchの実装に適した連続した値のセットが提供されるため。

Parameter passing semantic rules / 引数の意味論的なルール
F.22: Use T* or owner<T*> to designate a single object
(1つのオブジェクトを指すのにT*か(GSLの)owner<T*>を使う)

単純な型のポインターがさす情報は曖昧であるため、コードが何を意味して何をしようとしているのかがあいまいになってしまう。
配列のサイズやリソース開放の必要性などを判断しづらい。

F.23: Use a not_null<T> to indicate that "null" is not a valid value
(nullにならないことを示すのに(GSLの)not_null<T>を使う)

ポインタ変数に対してnot_nullでガードをかける。nullptrのチェックを関数の呼び出しもとが行うことを明確にする。
ただし、Callistoだとnot_nullはあまり使っていない。

F.24: Use a span<T> or a span_p<T> to designate a half-open sequence
(半開区間を指すには(GSLの)span<T>か(GSLの)span_p<T>を使う)

spanとspan_pは範囲走査を安全におこなうためのヘルパーであり、ポインタと同様に効率的に要素へアクセスできる。

Value return semantic rules / 戻り値の意味論的なルール
F.42: Return a T* to indicate a position (only)
(位置を知らせる場合に限りポインターを返す)

T*は所有権を移すためではなく、単一のオブジェクトの位置を示すために使用する。

F.43: Never (directly or indirectly) return a pointer or a reference to a local object
(ローカルオブジェクトの参照やポインターを決して返さない)

破棄されたオブジェクトを参照するポインタを使用することで、データの破損やソフトのクラッシュが起きるため。


F.44: Return a T& when copy is undesirable and "returning no object" isn’t needed
(コピーが望ましくなく、「値なし」が必要なければ参照を返す)

T&がオブジェクトを指すことは言語が保証しているので、nullptrのチェックを実装しなくて済む。

Other function rules / その他の関数のルール
F.50: Use a lambda when a function won’t do (to capture local variables, or to write a local function)
(関数が上手くいかないときはラムダ式を使う(ローカル変数をキャプチャーするか、ローカル関数を書きたい場合))

関数、ラムダ、関数オブジェクトを比較し手使用する。
関数オブジェクトで実装するよりもラムダを使うほうがシンプルになることが多い。

F.51: Where there is a choice, prefer default arguments over overloading
(デフォルト引数とオーバーロードを選べるときはデフォルト引数を使う)

インターフェースの種類を増やす際に、コードの複製を回避できるため。オーバーロードした場合はコピーコードが生まれる懸念がある。

F.52: Prefer capturing by reference in lambdas that will be used locally, including passed to algorithms
(標準アルゴリズムへ渡す場合を含めて、ローカルで使われるラムダ式は参照キャプチャーを優先する)

値渡しよりも参照渡しのほうがほとんどの場合でコストが低いため。
ただし、参照渡しは呼び出しもと周辺の処理に依存するという副作用がある。