I.7: State postconditions
(事後条件を明示する)

関数の処理の期待値を明確にする。リソース開放などに関しては可能な限り実装上で表現する。

I.8: Prefer Ensures() for expressing postconditions
(事後条件を明示するのにEnsures()を使う)

関数の処理の期待値をEnsures()で明示する。ただし、本案件ではほぼ使用ししていない。リソース開放などに関しては可能な限り実装上で表現する。

I.9: If an interface is a template, document its parameters using concepts
(インターフェースがテンプレートの場合、引数にコンセプトで注釈をつける)

C++20から導入される「コンセプト (concepts)」で、テンプレートパラメータを制約する。

I.10: Use exceptions to signal a failure to perform a required task
(必要な措置を講じるために失敗の通知には例外を使う)

エラーとは関数が呼びもとに期待された動作を実現できなかったこと。エラーを起こした場合は例外を投げるべき。例外を使えない場合は値,エラーコードの戻り値を検討する。

I.11: Never transfer ownership by a raw pointer (T*) or reference (T&)
(決して生ポインタで所有権を渡さない)

生ポインタはリソースリークや使用前のリリースを招き、バグにつながる。

I.12: Declare a pointer that must not be null as not_null
(nullになってはいけないポインターは、(GSLの)not_nullとして宣言する)

not_nullが定義されていないポインタを使用する際は常にnullの可能性を考慮する。not_nullはおそらく使用しない。

I.13: Do not pass an array as a single pointer
(配列をポインター1つだけで渡さない)

引数がポインタ+サイズの場合、その関数の中で配列の領域外アクセスをする可能性を防げない。引数をspanやvectorに変えることを検討する。

I.22: Avoid complex initialization of global objects
(グローバルオブジェクトの複雑な初期化は避ける)

翻訳単位が異なるグローバルオブジェクトの呼び出し順序は不定のため、グローバルオブジェクト同士が相互に参照して初期化すると一方は不定の値で初期化することになる。

I.23: Keep the number of function arguments low
(できるだけ引数の数は少なくする)

引数が多い関数は抽象化が足りていない。関数の処理パターンがコントロールできなくなりエラーにつながる。また、単一機能単一責任になっておらず、複数の役割を担おうとしており、リファクタの対象と判断できる。パラメータはなるべく4つまでとする。

I.24: Avoid adjacent unrelated parameters of the same type
(同じ型の無関係な引数が隣接しないようにする)

引数の順序が意味をなす場合に、同じ型がならぶとどちらが入力でどちらが出力なのかを読み手に混乱させる。配列のコピー元、コピー先など。
パラメータを構造体にして各引数の役割を変数名で明確にする。


I.25: Prefer abstract classes as interfaces to class hierarchies
(クラス階層よりもインターフェースとしての抽象クラスを使う)

データを持たないインタフェースクラスを継承したほうが、各継承クラスの実装がシンプルになる。

I.26: If you want a cross-compiler ABI, use a C-style subset
(コンパイラを跨ぐABIが必要なら、C言語の機能に絞ったサブセットを使う)

コンパイラによって、クラス、例外処理、関数名など、実装の詳細が異なるバイナリレイアウトを実装しているため。

I.27: For stable library ABI, consider the Pimpl idiom
(安定したライブラリのABIのためにPimplパターンの使用を検討する)

軽微な修正による再コンパイルを避けるためにPimplパターンの使用を検討する。

I.30: Encapsulate rule violations
(ルール違反をカプセル化する)

設計上どうしても必要なイレギュラーな実装は別のユーザーから参照できない内部の実装にとどめる。インタフェースとして見える箇所には漏れないようにする。

F.1: "Package" meaningful operations as carefully named functions
(意味のある一連の処理を関数に注意深く命名して、「まとめる」)

コードの可読性と再利用性を高めるために、アクションが一連の流れとして規定されているものは正しい名前をつけてまとめること。

F.2: A function should perform a single logical operation
(関数は論理的に1つの処理のみをするべきである)

シンプルな関数は読み手が理解しやすく、テスト、再利用もしやすい。

F.3: Keep functions short and simple
(関数は短くシンプルに保つ)

長い関数は制御も複雑になり、エラーを隠す可能性が高くなる。画面におさまらない関数は、意味のある単位で小さな関数に分割する。

F.4: If a function may have to be evaluated at compile time, declare it constexpr
(関数がコンパイル時に評価されうるなら、constexprで宣言する)

コンパイル時点でエラーチェックができROM化することができる。

F.5: If a function is very small and time-critical, declare it inline
(関数が非常に小さく時間的制約が強ければ、inlineで宣言する)


インライン関数はABIの一部のため、安定したインターフェイスであることを意図しているものには、今後の変更されないことが確実でない限り、インライン関数を置かない。
関数テンプレートは通常ヘッダ定義のためインラインになる。
constexprはinlineを意味する。
クラス内で定義されたメンバ関数は、デフォルトでインライン化されます。
★要確認

F.6: If your function may not throw, declare it noexcept
(関数が例外を投げないなら、noexceptで宣言する)

noexcept関数を宣言すると、代替実行経路の数を減らすことができ、最適化の助けになります。また、失敗後の終了を早めることができます。
C言語や例外のない他の言語で完全に書かれたすべての関数にnoexceptを付けるべき。
noexceptは、頻繁に使用される低レベルの関数に最も有効。

F.7: For general use, take T* or T& arguments rather than smart pointers
(一般的な用途の引数にはスマートポインタより普通のポインタまたは参照を使う)

スマートポインタ（std::shared_ptrなど）を渡すと、ランタイムコストが発生する。
★要検討

F.8: Prefer pure functions
(関数はできるだけ純粋関数(副作用のない関数)にする)

純粋関数はシンプルで最適化しやすくROM化もできるため。

F.9: Unused parameters should be unnamed
(使用しない仮引数に名前を付けてはいけない)

読みやすさの向上と未使用パラメータに対する警告を避けるため。
パラメータが条件付きで未使用になる場合は、[[maybe_unused]]属性で宣言する。

F.10: If an operation can be reused, give it a name
(再利用できる操作であれば、名前をつけておく。)

無名ラムダの役割が増えすぎた場合などに、その役割を明確にし、読みやすくする。

F.11: Use an unnamed lambda if you need a simple function object in one place only
₍シンプルな関数オブジェクトが一か所だけ必要な場合は、無名ラムダを使用します。₎

コードが簡潔になり、代替案よりも優れた局所性を得ることができます。名前付けはたとえ一度しか使用されない場合でも、わかりやすくするために有効です。

F.15: Prefer simple and conventional ways of passing information
(情報を渡す方法はシンプルかつ一般的なものにする)

一般的なテクニックを超えた最適化が本当に必要だと感じたら、それが本当に改善であることを確認するために測定し、改善が移植できないかもしれないので文書化/コメントする。

F.16: For "in" parameters, pass cheaply-copied types by value and others by reference to const
(入力用引数は、安価にコピーできる型は値で渡し、それ以外はconst参照で渡す)

高速かつ単純になり、安全性も確保できる。rvalueによる初期化を可能にする。
？？

F.17: For "in-out" parameters, pass by reference to non-const
(入出力用引数は非const参照で渡す)

非const参照の場合は更新されることが前提であると理解する。ただし、それ自体がバグを引き起こしかねない実装である。span<T>やイテレータはそれ自体が入出力引数になる。

F.18: For “will-move-from” parameters, pass by X&& and std::move the parameter
₍will-move-from」パラメータは、X&&とstd::moveでパラメータを渡します。₎
効率的で、呼び出し先でのバグをなくすことができる。
？？

F.19: For "forward" parameters, pass by T&& and only std::forward the parameter
(転送する引数はT&&にして、引数をstd::forwardする)
オブジェクトが他のコードに渡され、この関数で直接使用されない場合、この関数は引数のconst-nessとrvalue-nessに不可知論的であるようにしたいです。
？？

F.20: For "out" output values, prefer return values to output parameters
(値を返すには、出力用引数よりも戻り値を使う)

戻り値は役割が自明だが、&はin-outかout-onlyの2つの意味があり、誤用される可能性がある。ただし、charを複数持つ構造体などmoveの負荷が高いケースは戻り値だと最適化されない。

F.21: To return multiple "out" values, prefer returning a tuple or struct
(複数の値を返すには、タプルか構造体を使う)

戻り値は役割が自明であるため。戻り値に意味がある場合は構造体、それ以外はタプルを使用する。

F.60: Prefer T* over T& when "no argument" is a valid option
(「値なし」がありえるなら参照ではなくポインターを使う)

参照は関数内でのnullチェックの手間を省くことが一般的であるから。
？？.

C: Classes and class hierarchies / クラスとクラス階層
C.1: Organize related data into structures (structs or classes)
(関連するデータをクラスまたは構造体で組織化する)

可読性の向上のために、データの関連をコード上で表現すること。
仮想関数のない単純なクラスは、スペースや時間のオーバーヘッドがないため、classで表現することにデメリットは少ない。
class(private)とstruct(public)の違いは、メンバーのデフォルトの可視性だけ。

C.2: Use class if the class has an invariant; use struct if the data members can vary independently
(クラスが不変条件を持つならclassを、メンバーが独立に変更できるならstructを使う)

クラスを使用すると、不変条件の必要性がプログラマーに警告されます。？？
不変条件とは、公開関数によってしか変更できない、コンストラクションで初期化されるprivate変数のこと。
不変条件があるならクラスを使用する、ないなら構造体で実装する。

C.3: Represent the distinction between an interface and an implementation using a class
(クラスを使ってインターフェースと実装の区別を表現する)

可読性が向上し、メンテナンスが簡単になる。？？

C.4: Make a function a member only if it needs direct access to the representation of a class
(クラスの内部表現(※privateメンバー)に直接アクセスする必要がある場合に限り、関数をメンバーにする)

クラスのメンバ変数を使用して処理をする必要がない場合はヘルパー関数をクラス外に実装する。

C.5: Place helper functions in the same namespace as the class they support
(ヘルパー関数は対象とするクラスと同じ名前空間に置く)

ヘルパー関数はクラスのメンバ変数などに直接アクセスする必要はないが、クラスの有用なインターフェースの一部とみなされる関数です。クラスと同じ名前空間に置くことで、クラスとの関係が明らかになり、引数に依存した検索が可能になります。

C.7: Don’t define a class or enum and declare a variable of its type in the same statement
(クラスなどの定義とその型の変数の宣言を1文で書かない)

混乱を招くので、型の定義と変数の宣言は同じ行で行わない。

C.8: Use class rather than struct if any member is non-public
(publicではないメンバーがあるなら構造体ではなくクラスを使う)

外部に対して何かを隠したいという意思表示のためにクラスを使用する。
デフォルトがpribateのため、publicにするものを限定しているイメージ。

C.9: Minimize exposure of members
(メンバーの露出を最小限にする)

カプセル化することで、意図しないアクセスを最小化する。これにより、メンテナンスが簡素化される。
メンバ変数に対しての処理を追いやすくする。

C.concrete: Concrete types / 具象型
C.10: Prefer concrete types over class hierarchies
(クラス階層よりも具象クラスを使う)

具体的な型はスタックアロケートされ、他のクラスのメンバとなることができる。
クラス階層だとポインタや参照を通じてそのオブジェクトを操作する必要があり、メモリ・オーバーヘッドなどランタイム・オーバーヘッドになる。

C.11: Make concrete types regular
(具象型の振る舞いを一般的なものにする)

代入や等式など一般的なインターフェースを使用可能なクラス設計にする。理解しやすくなるため。
等価比較演算子も実装して置くのが望ましい。

C.12: Don’t make data members const or references
(データメンバーをconstまたは参照にしない)

コピーできないメンバ変数を持つことは方を使いづらくする。₍参照も部分敵にコピー付加となる。₎

Enum: Enumerations / 列挙
Enum.1: Prefer enumerations over macros
(マクロより列挙型を使う)

マクロはスコープや型の規則がない。同名を複数個所で定義できるため、意図しないマクロが使用されてしまう可能性がある。
また、マクロは前処理中に削除されるため、デバッガーなどのツールでは表示されない。デバッグしづらい。

Enum.2: Use enumerations to represent sets of related named constants
(名前の付いた定数のセットを表すのに列挙型を使う)

関連する定数のセットを、名前付きの型にすることができます。
列挙型にすることで大文字と小文字の違いなど異常なパターンに対してコンパイラがチェックできる。
switch構文で抜け漏れを防ぐこともできる。

Enum.3: Prefer enum classes over "plain" enums
(素のenumよりenum classを使う)

意図しない挙動を最小限にする。従来のenumはintに型変換されて、ほかのラベルを期待する場合でもそれなりにふるまってしまう。
enum classを使えば期待するenumのみを使用しているのかをコンパイラがチェックできる。

Enum.4: Define operations on enumerations for safe and simple use
(列挙型に演算子を定義して安全かつシンプルに使えるようにする)

使いやすさとエラーの回避。面倒な処理のカプセル化と個別の実装でミスをすることによるエラーを回避する。

Enum.5: Don’t use ALL_CAPS for enumerators
(列挙型の名前を全て大文字の名前にしない)

マクロとの衝突を避けるため。

Enum.6: Avoid unnamed enumerations
(無名の列挙型を避ける)

列挙型に名前を付けることができない場合、それは値の設計ができていないことをさす。
関連がないのなら個別にconstexpr で宣言すること。

Enum.7: Specify the underlying type of an enumeration only when necessary
(列挙型の基本型は必要な場合のみ与える)

フォルトは、読み書きが最も簡単です。 デフォルトはintで、C 列挙型と互換性があります。
またメモリの節約にもなる。

Enum.8: Specify enumerator values only when necessary
(列挙子の値は必要な場合のみ与える)

列挙値の重複や抜けを回避し、switchの実装に適した連続した値のセットが提供されるため。

Parameter passing semantic rules / 引数の意味論的なルール
F.22: Use T* or owner<T*> to designate a single object
(1つのオブジェクトを指すのにT*か(GSLの)owner<T*>を使う)

単純な型のポインターがさす情報は曖昧であるため、コードが何を意味して何をしようとしているのかがあいまいになってしまう。
配列のサイズやリソース開放の必要性などを判断しづらい。

F.23: Use a not_null<T> to indicate that "null" is not a valid value
(nullにならないことを示すのに(GSLの)not_null<T>を使う)

ポインタ変数に対してnot_nullでガードをかける。nullptrのチェックを関数の呼び出しもとが行うことを明確にする。
ただし、Callistoだとnot_nullはあまり使っていない。

F.24: Use a span<T> or a span_p<T> to designate a half-open sequence
(半開区間を指すには(GSLの)span<T>か(GSLの)span_p<T>を使う)

spanとspan_pは範囲走査を安全におこなうためのヘルパーであり、ポインタと同様に効率的に要素へアクセスできる。

Value return semantic rules / 戻り値の意味論的なルール
F.42: Return a T* to indicate a position (only)
(位置を知らせる場合に限りポインターを返す)

T*は所有権を移すためではなく、単一のオブジェクトの位置を示すために使用する。

F.43: Never (directly or indirectly) return a pointer or a reference to a local object
(ローカルオブジェクトの参照やポインターを決して返さない)

破棄されたオブジェクトを参照するポインタを使用することで、データの破損やソフトのクラッシュが起きるため。


F.44: Return a T& when copy is undesirable and "returning no object" isn’t needed
(コピーが望ましくなく、「値なし」が必要なければ参照を返す)

T&がオブジェクトを指すことは言語が保証しているので、nullptrのチェックを実装しなくて済む。

Other function rules / その他の関数のルール
F.50: Use a lambda when a function won’t do (to capture local variables, or to write a local function)
(関数が上手くいかないときはラムダ式を使う(ローカル変数をキャプチャーするか、ローカル関数を書きたい場合))

関数、ラムダ、関数オブジェクトを比較し手使用する。
関数オブジェクトで実装するよりもラムダを使うほうがシンプルになることが多い。

F.51: Where there is a choice, prefer default arguments over overloading
(デフォルト引数とオーバーロードを選べるときはデフォルト引数を使う)

インターフェースの種類を増やす際に、コードの複製を回避できるため。オーバーロードした場合はコピーコードが生まれる懸念がある。

F.52: Prefer capturing by reference in lambdas that will be used locally, including passed to algorithms
(標準アルゴリズムへ渡す場合を含めて、ローカルで使われるラムダ式は参照キャプチャーを優先する)

値渡しよりも参照渡しのほうがほとんどの場合でコストが低いため。
ただし、参照渡しは呼び出しもと周辺の処理に依存するという副作用がある。


ES: Expressions and statements / 式と文
ES.1: Prefer the standard library to other libraries and to "handcrafted code"
(自作や非標準の物より、標準ライブラリを使う)
ライブラリを使用すると、言語機能を直接操作するコードよりも簡単に短く記述できる。
また、ライブラリのコードは動作を保障されている。
ただし、ライブラリの多くは動的メモリ割り当てに依存している。その場合は別途対策が必要。

ES.2: Prefer suitable abstractions to direct use of language features
(言語機能を直接使うより適切な抽象化を使う)

コンテナなどを使うことにより、コードが短く簡潔になり、適切なテストができるようになる。
エラーのチェック処理などのコードを実装する量が減る。

ES.3: Don’t repeat yourself, avoid redundant code
₍繰り返さないでください。冗長なコードは避けてください₎

コピーコードや冗長なコードはロジックの理解を難しくし、メンテナンスがしづらくなる。
独自の実装を作成する代わりに、必要に応じて標準アルゴリズムを使用すること。
ifの分岐処理なども重複したコードが内容に設計する。

ES.dcl: Declarations / 宣言
ES.5: Keep scopes small
(スコープを小さく保つ)

可読性とリソース使用範囲の制限のため。不必要に大きなスコープで変数を宣言しない。

ES.6: Declare names in for-statement initializers and conditions to limit scope
(条件部やfor文の初期化部で名前を宣言し、スコープを制限する)

可読性のため。ループの後でループ変数をほかの目的に使用されることを回避する。
ただし、for文の条件部には実行コストの高い処理は含めない。関数呼び出しなど。
C++17 and C++20ではif文での初期化ステートメントも実装さている。₍初期化後に初期化した値で判定する構文₎

ES.7: Keep common and local names short, and keep uncommon and nonlocal names longer
(一般的で局所的な名前は短く、そうでない名前は長くする)

可読性のため。 関連のない名前同士の衝突の可能性を下げる。
ローカルに収まらないコードでの短い名前は読みやすさを妨げる。

ES.expr: Expressions / 式
ES.40: Avoid complicated expressions
(複雑な式を避ける)

以下のような構文は混乱を招く。
・条件分岐内の代入式
・条件式内の複数のローカル変数
・部分式に隠された代入式
・優先順位規則に依存した₍₎のない構文

ES.41: If in doubt about operator precedence, parenthesize
(演算子の優先順位が疑わしい場合、カッコを使う)

優先順位規則を常に覚えているわけではないので、カッコをつけて読みやすくすること。

ES.42: Keep use of pointers simple and straightforward
(ポインターの使用箇所は単純明快にする))

ポインター使用して、インクリメントや添え字で連続領域にアクセスするような実装は避けること。
配列に対しての反復子が必要な場合はspanを使用する。

ES.stmt: Statements / 文
ES.70: Prefer a switch-statement to an if-statement when there is a choice
(選べるならif文よりswitch文を使う)

可読性。switchは定数との比較になり、テストも容易になる。
また、条件分岐のチェック機能も備えている。₍defaultの考慮、分岐の抜け漏れ₎

ES.71: Prefer a range-for-statement to a for-statement when there is a choice
(選べるならfor文より範囲for文を使う)

可読性とエラー回避。ループの本体で「ループ変数をいじる」ことは避けるべき。
その際にループ変数のコピーも内容にする。

ES.72: Prefer a for-statement to a while-statement when there is an obvious loop variable
(明確なループ変数があるならwhile文よりfor文を使う)

どのようにどこまで繰り返すのが明確になるから。

Arithmetic / 算術
ES.100: Don’t mix signed and unsigned arithmetic
(符号ありと符号なしの計算を混在させない)

意図しない値になることを避けるため。
※C++ は配列の添え字に符号付き整数を使用し、標準ライブラリはコンテナの添え字に符号なし整数を使用する。

ES.101: Use unsigned types for bit manipulation
(ビット演算には符号なしの型を使う)

符合の有無による意図しない値への変化を避ける。

ES.102: Use signed types for arithmetic
(算術演算には符号ありの型を使う)

算術演算は符合付きを前提として多くの処理が実装されているため。

Per: Performance / パフォーマンス
Per.1: Don’t optimize without reason
(訳もなく最適化しない)

パフォーマンスが期待値を満たす状態での最適化は、エラーの増加とメンテナンス コストの増加をまねく。

Per.2: Don’t optimize prematurely
(早すぎる最適化をしない)

最適化されたコードは最適化されていないコードよりもサイズが大きく、変更が難しくなる。
ほかの人が修正しにくいコードになっている。

Per.3: Don’t optimize something that’s not performance critical
(パフォーマンス上重要でない部分を最適化しない)

最適化の対象を感覚で決めてしまうと、局所的に改善にしかならない。
ソフトを使用する全体でみると些細な効果しか出ないかもしれない。

Per.4: Don’t assume that complicated code is necessarily faster than simple code
(複雑なコードがシンプルなコードより早いと思わない)

高速化を目指して複雑にしたことで結果的に遅くなるケースがある。
シンプルなコードのほうがコンパイル時の最適化の結果として早くなるケースは多々ある。

Per.5: Don’t assume that low-level code is necessarily faster than high-level code
(低レベルなコードが高レベルなコードより早いと思わない)

低レベルなコードはコンパイラによる最適化を受けにくい。
高レベルなコードのほうがコンパイラによる最適化が効果を発揮することがある。

Per.6: Don’t make claims about performance without measurements
(計測せずに意見しない)

一般論や経験則で改善を行うとパフォーマンスの改善を適切に行えない。
計測し、クリティカル箇所をデータやツールを用いて導き出すこと。
プロファイラを使えばより効率的にシステムの見えるかをできる。

Per.7: Design to enable optimization
(最適化できるように設計する)

改善の見通しを立てずに設計した場合は後工程での修正が大変になる。

Per.10: Rely on the static type system
(静的型システムを信頼する)

単純な型を使用すると最適化がされやすくなる。

Per.11: Move computation from run time to compile time
(実行時処理をコンパイル時処理に変える)

コードサイズと実行時間を短縮できる。₍コンパイル時にエラー処理をすることで、実行時チェックのコードが減る。₎

Per.12: Eliminate redundant aliases
(冗長なエイリアスを除去する)

※記載なし。

CP: Concurrency and parallelism / 並行・並列処理
CP.1: Assume that your code will run as part of a multi-threaded program
(マルチスレッドプログラムの一部として実行される可能性を考慮する)

コードは再利用されるため、今後の修正でマルチスレッドの中で実行される可能性がある。
ライブラリコードに対してはこのルールをマストで適用すること。

CP.2: Avoid data races
(データ競合を避ける)

動作が保証できず解析しにくいエラーが起きる。
ローカル静的変数などが問題個所となる。

CP.3: Minimize explicit sharing of writable data
(書き込み可能なデータの明示的な共有を最小限にする)

変更可能なデータの共有範囲は最小限にする。

CP.4: Think in terms of tasks, rather than threads
(スレッドよりもタスクで考える)

スレッドは実装の概念であり、マシンに関する考え方です。 
タスクはアプリケーションの概念であり、できれば他のタスクと同時に実行したいものです。 
アプリケーションの概念は、簡単に推論できます。

CP.8: Don’t try to use volatile for synchronization
(同期のためにvolatileを使おうとしない)

volatileはメモリー・アクセス処理を分割しないことを保障しない。
volatileではなくatomic or mutexを使用する。

CP.9: Whenever feasible use tools to validate your concurrent code
(並行処理のコードを検証するのにツールが使えるときは使う)

基本的なテストでは順次実行されるコードのエラーしか正しく評価できない。
静的解析ツール(clang)や 動的解析ツール(Thread Sanitizer)を活用する。

CP.con: Concurrency / 並行処理
CP.20: Use RAII, never plain lock()/unlock()
(素のlock()/unlock()を避け、RAIIにする)

ロックの解放漏れを防ぐためにデストラクタで解放するクラスを使用する。₍unique_lockなど₎

CP.21: Use std::lock() or std::scoped_lock to acquire multiple mutexes
(複数のミューテックスを獲得するのにstd::lock()やstd::scoped_lockを使う)

std::adopt_lockやscoped_lockを使用してデッドロックを回避する。

CP.22: Never call unknown code while holding a lock (e.g., a callback)
(ロックを持っている間、コールバックのような未知のコードを決して呼び出さない)


CP.mess: Message passing / メッセージパッシング
CP.60: Use a future to return a value from a concurrent task
(並行するタスクから値を返すにはfutureを使う)


CP.61: Use an async() to spawn a concurrent task
(並行タスクをスポーンするにはasync()を使う)

CP.free: Lock-free programming / ロックフリープログラミング
CP.100: Don’t use lock-free programming unless you absolutely have to
(本当に必要な場合を除き、ロックフリープログラミングをしない)


CP.101: Distrust your hardware/compiler combination
(自分のハードウェア、コンパイラの組み合わせを信用しない)


CP.102: Carefully study the literature
(文献で入念に勉強する)

CP.etc: Etc. concurrency rules / その他
CP.200: Use volatile only to talk to non-C++ memory
(volatileはC++外のメモリーを読み書きするためだけに使う)
